import{a as P}from"./dashboard-Ks6BhIBF.js";import{v as S,r as h}from"./index-bpa48Sxk.js";const D="dawapi_notifications",q=1,f="notifications",y="read_notifications";let b=null,j=null;function x(o){j=o}function p(){if(!j)throw new Error("API Key not set. Please call setCurrentApiKey first.");return j}function N(o){return`${p()}:${o}`}function w(){return new Promise((o,r)=>{if(b){o(b);return}const c=indexedDB.open(D,q);c.onerror=()=>{r(new Error("Failed to open database"))},c.onsuccess=l=>{b=l.target.result,o(b)},c.onupgradeneeded=l=>{const s=l.target.result;if(!s.objectStoreNames.contains(f)){const a=s.createObjectStore(f,{keyPath:"compositeId"});a.createIndex("apiKey","apiKey",{unique:!1}),a.createIndex("created_at","created_at",{unique:!1}),a.createIndex("type","type",{unique:!1}),a.createIndex("apiKey_createdAt",["apiKey","created_at"],{unique:!1})}s.objectStoreNames.contains(y)||s.createObjectStore(y,{keyPath:"compositeId"}).createIndex("apiKey","apiKey",{unique:!1})}})}async function E(o){const r=await w(),c=p(),s=r.transaction([f],"readwrite").objectStore(f),a=o.map(d=>new Promise((u,t)=>{const e=N(d.id),i={...d,compositeId:e,apiKey:c,originalId:d.id},n=s.put(i);n.onsuccess=()=>u(),n.onerror=()=>t(n.error)}));await Promise.all(a)}async function R(){const o=await w(),r=p(),s=o.transaction([f],"readonly").objectStore(f).index("apiKey_createdAt"),a=new Date;a.setHours(0,0,0,0);const d=a.toISOString();return new Promise((u,t)=>{const e=IDBKeyRange.bound([r,d],[r,new Date().toISOString()]),i=s.openCursor(e,"prev"),n=[];i.onsuccess=A=>{const g=A.target.result;g?(n.push(g.value),g.continue()):u(n)},i.onerror=()=>{t(i.error)}})}async function T(o){const r=await w(),c=p(),s=r.transaction([y],"readwrite").objectStore(y);return new Promise((a,d)=>{const u=N(o),t=s.put({compositeId:u,apiKey:c,originalId:o,readAt:new Date().toISOString()});t.onsuccess=()=>a(),t.onerror=()=>d(t.error)})}async function C(o){const r=await w(),c=p(),s=r.transaction([y],"readwrite").objectStore(y),a=o.map(d=>new Promise((u,t)=>{const e=N(d),i=s.put({compositeId:e,apiKey:c,originalId:d,readAt:new Date().toISOString()});i.onsuccess=()=>u(),i.onerror=()=>t(i.error)}));await Promise.all(a)}async function O(){const o=await w(),r=p(),s=o.transaction([y],"readonly").objectStore(y).index("apiKey");return new Promise((a,d)=>{const u=s.getAll(r);u.onsuccess=()=>{const t=u.result.map(e=>e.originalId);a(t)},u.onerror=()=>{d(u.error)}})}async function k(){const o=await w(),r=p(),s=o.transaction([f],"readwrite").objectStore(f).index("apiKey"),a=new Date;a.setHours(0,0,0,0);const d=a.getTime();return new Promise((u,t)=>{const e=s.openCursor(r);e.onsuccess=i=>{const n=i.target.result;if(n){const A=n.value;new Date(A.created_at).getTime()<d&&n.delete(),n.continue()}else u()},e.onerror=()=>{t(e.error)}})}async function $(){try{await k(),console.log("Non-today notifications cleaned")}catch(o){console.error("Failed to clean non-today notifications:",o)}}const m=h([]),I=h(0),K=h(!1),v=h(!1);let _=null;function B(){async function o(t){if(!t){console.error("API Key is required for notifications");return}try{x(t),await $(),await r(),v.value=!0}catch(e){console.error("Failed to initialize notifications:",e)}}async function r(){try{const t=await R();m.value=t,await l()}catch(t){console.error("Failed to load today notifications:",t),m.value=[]}}async function c(){try{K.value=!0;const e=(await P()).data||{},i=[];e.sys_news&&e.sys_news.forEach(n=>{i.push({...n,type:"system",id:n.id||n.created_at||`sys_${Date.now()}_${Math.random()}`})}),e.user_news&&e.user_news.forEach(n=>{i.push({...n,type:"user",id:n.id||n.created_at||`user_${Date.now()}_${Math.random()}`})}),e.dna_news&&e.dna_news.forEach(n=>{i.push({...n,type:"dna",id:n.id||n.created_at||`dna_${Date.now()}_${Math.random()}`})}),i.length>0&&await E(i),await r()}catch(t){console.error("获取通知失败:",t)}finally{K.value=!1}}async function l(){try{const t=await O();I.value=m.value.filter(e=>!t.includes(e.originalId||e.id)).length}catch(t){console.error("Failed to update unread count:",t),I.value=0}}async function s(t){try{await T(t),await l()}catch(e){console.error("Failed to mark notification as read:",e)}}async function a(){try{const t=m.value.map(e=>e.originalId||e.id);await C(t),I.value=0}catch(t){console.error("Failed to mark all notifications as read:",t)}}function d(t=6e4){c(),_=setInterval(()=>{c()},t)}function u(){_&&(clearInterval(_),_=null)}return{news:S(()=>m.value),unreadCount:S(()=>I.value),loading:S(()=>K.value),initialized:S(()=>v.value),initialize:o,fetchNews:c,loadTodayNews:r,markAsRead:s,markAllAsRead:a,startPolling:d,stopPolling:u}}export{O as g,B as u};
